[% PERL %]

use warnings; no warnings "redefine";

use strict;

our $is_prod = "prod" eq ($ENV{ENVIRONMENT} || "dev");

{
package My::Backend;
use Net::DNS;
use Socket qw(inet_ntoa);

sub all {
  my ($class, $service_name) = @_;
  my @hostnames;
  if ($ENV{DEBUG}) {
     if ($service_name eq "gitlab") {
        @hostnames = qw(gitlabdocker_gitlab.1.xyz.foo gitlabdocker_gitlab.2.xyz.foo gitlabdocker_gitlab.3.xyz.foo);
     } else {
        @hostnames = ("gitlabdocker_${service_name}.1.xyz.foo");
     }
  } else {
    my $r = Net::DNS::Resolver->new;
    @hostnames = sort map {
      my $ptrname = _ptrname($r, $_->{address});
    } $r->search($service_name . ".", "A")->answer;
  }
  return map { bless { name => $_ }, "My::Backend" } @hostnames;
}

sub _ptrname {
  my ($r, $inet_address) = @_;
  my $ptr;
  foreach my $i (1..10) {
    my ($ptr) = $r->search(inet_ntoa($_->{address}), "PTR")->answer;
    my $ptrname = $ptr->ptrdname;
    return $ptrname if defined(My::Backend::num({name => $ptrname}));
  }
  warn "Unable to resolve " . inet_ntoa($_->{address}) . " properly; last attempt gave out $ptr";
  return undef;
}

sub nth {
    my ($class, $service_name, $num) = @_;
    my ($nth) = grep { $_->num == $num } $class->all($service_name);
    return $nth;
}

sub name { shift->{name} }

sub num {
  my ($self) = @_;
  my ($num) = $self->{name} =~ m/\.(\d+)\./;
  return $num;
}
}

[% END %]

[% PERL %]

# Sub-template, yow!
sub upstream_block {
    my ($block_name, $opt_port_suffix) = @_;
    $opt_port_suffix ||= "";
    my $_out = "";
[% END %]

     upstream [% block_name %] {
     [% PERL %]
     foreach my $host (grep {$_->num <= 2} My::Backend->all("gitlab")) {
       my $hostname = $host->name;
     [% END %]
           server [% hostname %][% opt_port_suffix %];
     [% PERL %]
     }  # foreach my $hostname
     if ($opt_port_suffix) {
     [% END %]
           server 127.0.0.1[% opt_port_suffix %];
     [% PERL %]
     } else {
     [% END %]
           server 127.0.0.1 down;
     [% PERL %]
     }
     [% END %]
     }
[% PERL %]
     $_out;
};
[% END %]

worker_processes  5;
events {
  worker_connections  4096;  ## Default: 1024
}

http {

[% PERL %]
if ($is_prod) {
   $_out .= upstream_block("prod");
}

# TODO: what if there is no 3? (During a rolling update)
our $backend_name = $is_prod ? "prod" : My::Backend->nth("gitlab", 3)->name;
our $plantuml_backend = 
[% END %]

    server {
        listen 443;
        ssl on;
        ssl_certificate        /etc/ssl/gitlab.epfl.ch.crt;
        ssl_certificate_key    /etc/ssl/gitlab.epfl.ch.key;

        proxy_connect_timeout   1s;
        proxy_send_timeout   10s;

        location = /assets/50x.html {
            internal;
            root /;
        }

        location / {
            proxy_set_header HOST $host;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            proxy_pass http://[% backend_name %];
            error_page 500 /assets/50x.html;
            error_page 501 /assets/50x.html;
            error_page 502 /assets/50x.html;
            error_page 503 /assets/50x.html;
            error_page 504 /assets/50x.html;
        }

        location /plantuml {
            proxy_set_header HOST $host;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            error_page 502 /assets/502.html;
        }
    }
}

# TCP load balancing / redirect for ssh
stream {
[% PERL %]
if ($is_prod) {
   $_out .= upstream_block("ssh_prod", ":22");
}
our $ssh_backend_name = $is_prod ? "ssh_prod" : My::Backend->nth("gitlab", 3)->name . ":22";
[% END %]

    server {
        listen 22;
        proxy_pass [% ssh_backend_name %];
    }
}
